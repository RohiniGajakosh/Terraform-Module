name : Terraform CI Pipeline
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
jobs:
  terraform:
    name: Terraform CI for Format and Validate
    runs-on: ubuntu-latest
    env:
      TF_TOKEN_app_terraform_io: ${{ secrets.TF_API_TOKEN }}   # Sets the Terraform Cloud API token as an environment variable for Terraform to authenticate with Terraform Cloud.
    steps:
    - name: Checkout code
      uses: actions/checkout@v2   # Checks out the repository code so that Terraform can access the configuration files.
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4  # Configures AWS credentials for Terraform to interact with AWS resources.
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    - name: Set up Terraform
      uses: hashicorp/setup-terraform@v3   # Sets up the specified version of Terraform for use in the workflow.
      with:
        terraform_version: 1.14.3
    - name: Terraform Init
      run: terraform init
    - name: Terraform Format
    #   run: terraform fmt -check
      run: terraform fmt -write=true
    - name: Terraform Validate
      run: terraform validate
    - name: Terraform Destroy
      run: terraform destroy -auto-approve
    #commented since im using terraform vcs integration to plan and apply so the plan and apply steps are not needed in the ci pipeline. The ci pipeline is only for format and validate.
    #the flow is that when we push code to the main branch, the ci pipeline will run and check for format and validate. If the format and validate steps are successful, then the code will be merged to the main branch and then the terraform cloud vcs integration will automatically trigger the plan and apply steps in terraform cloud. This way we can ensure that the code is always in a good state before it is applied to the infrastructure.
    # - name: Terraform Plan
    #   env:
    #     TF_VAR_DBUSERNAME: ${{ secrets.TF_VAR_DBUSERNAME }}   # Passes the database username as an environment variable to Terraform during the plan step.
    #   run: terraform plan -out=tfplan
    # - name: Terraform Apply
    #   if: github.event_name == 'workflow_dispatch'       
    #   env:
    #     TF_VAR_DBUSERNAME: ${{ secrets.TF_VAR_DBUSERNAME }}   
    #   run: terraform apply -auto-approve tfplan